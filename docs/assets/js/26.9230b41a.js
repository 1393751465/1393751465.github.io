(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{320:function(n,e,s){"use strict";s.r(e);var t=s(7),a=Object(t.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[n._v("昨天面试百度遇到一个比较有趣的问题，js文件之间存在依赖关系，那么加载的时候，加载顺序是什么样子的。")]),n._v(" "),e("p",[n._v("后续仔细考虑了这个小算法，这不就是拓扑排序，")]),n._v(" "),e("p",[n._v("我们在一开始学习js语法的时候，大概都会学到不同的依赖文件是如何去加载的。核心的思想就是先加载不被其他文件的依赖，然后加载那些依赖已经加载的文件，以此类推。")]),n._v(" "),e("p",[n._v("比如说：")]),n._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("const")]),n._v(" dependencies "),e("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n  "),e("span",{pre:!0,attrs:{class:"token string-property property"}},[n._v("'index.js'")]),e("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("[")]),e("span",{pre:!0,attrs:{class:"token string"}},[n._v("'1.js'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[n._v("'2.js'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n  "),e("span",{pre:!0,attrs:{class:"token string-property property"}},[n._v("'2.js'")]),e("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("[")]),e("span",{pre:!0,attrs:{class:"token string"}},[n._v("'1.js'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n  "),e("span",{pre:!0,attrs:{class:"token string-property property"}},[n._v("'1.js'")]),e("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("[")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v("\n")])])]),e("p",[n._v("上面的这个数据结构描述了，index.js 文件是依赖于1.js 2.js， 而2.js依赖于1.js")]),n._v(" "),e("p",[n._v("那么加载的时候，加载顺序就是 1.js 2.js index.js")]),n._v(" "),e("p",[n._v("简单来说就是获取依赖树（或者依赖图）的拓扑排序")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 那么我们从获取拓扑序列的思路来解决这道题\nconst dependencies = {\n    'index.js': ['1.js', '2.js'],\n    '2.js': ['1.js'],\n    '1.js': [],\n  };\n\nfunction getTopo(dependencies){\n    let dep = dependencies\n    let res = new Set()\n\n    while(Object.keys(dep).length!==0){\n    \t\t//遍历查找入度为0的节点，也就是不依赖于其他的文件的js\n        Object.keys(dep).forEach(key=>{            \n            if(dep[key].length==0){\n            \t\t//加到集合里面\n                res.add(key)\n                //删除这个文件，并且删除其他文件对该文件的依赖\n                delete dep[key]\n                var deleteKey = key\n                Object.keys(dep).forEach(key =>{\n                    const indexOfKey = dep[key].indexOf(deleteKey);\n                    if (indexOfKey !== -1) {\n                        dep[key].splice(indexOfKey, 1); \n                    }\n                })\n            }\n        })\n        \n        // 重复上述过程，直到dependencies为空\n    }\n\n    console.log(res)\n}\n\n")])])]),e("p",[n._v("这样的纯暴力的解法，复杂度太高了，有没有更好的算法？ 有！！")]),n._v(" "),e("p",[n._v("我们可以看成是对一个依赖树的遍历，我们不考虑重复问题")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/ 用于存储已加载的文件的集合\nconst loadedFiles = new Set();\n\n// 定义加载文件的函数\nfunction loadFile(fileName) {\n// 如果文件已加载，则直接返回\nif (loadedFiles.has(fileName)) {\n    return;\n}\n\n// 获取文件的依赖项列表\nconst fileDependencies = dependencies[fileName];\n\n// 递归加载依赖项\nfileDependencies.forEach(dependency => {\n    loadFile(dependency);\n});\n\n// 模拟加载文件的操作，可以在这里执行实际的加载操作\nconsole.log(`加载文件: ${fileName}`);\n\n// 将文件标记为已加载\nloadedFiles.add(fileName);\n}\n\n// 加载入口文件\n// loadFile('index.js');\n\n\n\n")])])]),e("p",[n._v("妙")])])}),[],!1,null,null,null);e.default=a.exports}}]);